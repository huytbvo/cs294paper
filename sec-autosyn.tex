\section{Automatic Pipeline Synthesis}

\subsection{Pipeline Register Placement and Stage Coloring}
{\bf Runtime}. The user annotates a set of combinational logic nodes and architectural state read/write ports with pipeline stage numbers. The user can annotate only the big pieces of combinational logic and architectual state they care about, such as ALUs, register files, or caches, and the automatic synthesis tool will infer the placement of all the other parts of the datapath. Of course, the user gains more control over the placement of the pipeline registers by adding more pipeline stage annotations. The user can have complete control over the placement of the pipeline registers if they annotate every combinational logic node and read/write port in the datapath.

{\bf Elaboration time}. The elaboration time transformation function first breaks the original cyclic Chisel Node graph into an acyclic graph by separating architectual states into read ports and write ports. Then the known pipeline stage numbers from the user annotated Chisel Nodes are propagated to their producers and consumers in a pseudo breadth-first-search(BFS) manner. When two propagation frontiers meet at the same node, propagation down that path stops and pipeline registers are inserted at that node. We also record the stage numbers of all Chisel Nodes after the stage propagation and pipeline register insertion for use in detecting pipeline hazards in the next stage of the automatic pipeline synthesis.

{\bf Pipeline Stage Propagation Details}. Nodes and their stage numbers are kept track of in a map of Nodes to List of Stage Numbers that we will refer to as the stage number map. Initially, only the user annotated nodes have non-empty values in the stage number map. In the pseudo BFS traversal, the propagation frontier(ie the nodes that have yet to propagate out their stage numbers) is kept track of with a queue. The propagation frontier queue is initialized with the user annotated nodes. As with a normal BFS traversal, the head of the propagation frontier queue is dequeued, some visit operation is performed on the dequeued node, and its children, which includes both producers and consumers, are enqueued onto the propagation frontier queue. Unlike a normal BFS traversal, the dequeued node maybe re-enqueued by the visit operation. In this case, the visit operation tries to propagate out the stage number of the dequeued node to its children by appending the dequeued node's stage number to its children's stage number list in the stage number map if the node is not the meeting point of two propagation frontiers, but re-enqueues the node for a retry later if it is not currently possible to propagate out the node's stage number. The node can propagate out its stage number if the following conditions are true: (1) the node has exactly one stage number in its stage number list in the stage number map and (2) all of the nodes children are ready to receive a stage number. 

Condition (1) makes sure that the propagation front has reached the node, which means that the node has atleast one stage number in its stage number list, and that two propagation frontiers have not meet at that node, which would mean that the node has less than 2 stage numbers in its stage number list. 

Condition (2) makes sure that the node propagates out its stage number to all of its children in an atomic manner. This is necessary because the propagation would produce incorrect results if the node managed to propagate out its stage number to only some of its children before two propagation frontiers meet at that node and stop the node from propagating its stage to the rest of its children. The node can only propagate its stage number to all of its children atomically if it waits until all of its children are ready and propagates to all of them at the same time, before the next node dequeued from the propagation frontier queue. The next paragraph discusses why some children may not be immediately ready to receive a stage number propagation.

We need to check that nodes are ready to receive a stage number because we need to enforce that a node has a stage number >= the stage numbers of all of its producer nodes and <= the stage numbers for all of its consumer nodes. For nodes with multiple producers, such as combinational logic nodes, the stage number propagated to the node from the producer side should be the maximum of the stage numbers of all of its producers. Also for nodes with multiple consumers the stage number propagated to the node from the consumer side should be minimum of the stage number of all its consumers. Thus, a node is ready to receive a stage number propagation from its producer side if a propagation frontier has reached all of its producer nodes and a node is ready to receive a stage number propagation from its producer side if a propagation frontier has reached all of its consumer nodes.

Once the stage number propagation is complete, we traverse the Chisel Node graph again and insert the appropriate number of pipeline registers between any adjacent nodes with different stage numbers and on any nodes with more than one stage number in its stage numbers list in the stage numbers map. Refer to [figure xx] for pseudo code on the stage number propagation algorithm.
\subsection{Hazard Discussion}

{\bf Hazard Types}.

{\bf Detection}.

\subsection{Hazard Resolution Options}

{\bf Interlocks}.

{\bf Speculation}.

{\bf Bypassing}.
